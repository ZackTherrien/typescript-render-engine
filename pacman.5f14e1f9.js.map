{"version":3,"sources":["../src/types.ts","../src/Engine/index.ts","../src/RenderingLayer/index.ts","../src/index.ts","pacman/constants.ts","pacman/entities/animal.ts","pacman/entities/background.ts","pacman/entities/pacman.ts","pacman/entities/score.ts","pacman/entities/manager.ts","pacman/index.ts"],"names":[],"mappings":"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","file":"pacman.5f14e1f9.js","sourceRoot":"../examples","sourcesContent":["/**\n * The function used to render a layer from the engine\n */\nexport type RenderLayerFunction = () => void;\n\n/**\n * Function used to update a layer\n */\nexport type UpdateLayerFunction = (deltaTime: number) => void;\n\n/**\n * The function used to render entities within a layer\n */\nexport type RenderFunction = (context: CanvasRenderingContext2D) => void;\n\n/**\n * Function used to update entities within a layer\n */\nexport type UpdateFunction = (deltaTime: number) => void;\n\n/**\n * Inteface for a generic entity with a render and optional update statement.\n */\nexport interface IEntity {\n\trender: RenderFunction;\n\tupdate?: UpdateFunction;\n}\n\n/**\n * Type of a layer index\n */\nexport type LayerIndex = number;\n\n/**\n * Enum for the layer types.\n * STATIC will not re-render every frame.\n * DYNAMIC will update and re-render every frame.\n */\nexport enum LayerType {\n\tSTATIC,\n\tDYNAMIC,\n}\n","import { IRenderingLayer } from '../RenderingLayer';\n\nimport { LayerType, LayerIndex } from '../types';\n\nexport interface IEngine {\n\t/**\n\t * Start rendering\n\t */\n\tstart(): void;\n\n\t/**\n\t * Stop rendering\n\t */\n\tstop(): void;\n\n\t/**\n\t * Get a layer based on it's index and layer type.\n\t * @param layerIndex The z-index of a layer\n\t * @param layerType The layer type of the layer wanted\n\t */\n\tgetLayer(layerIndex: LayerIndex, layerType: LayerType): IRenderingLayer | null;\n\n\t/**\n\t * Add a layer to the engine.\n\t * @param layer Layer to add to the engine\n\t */\n\tregisterLayer(layer: IRenderingLayer): void;\n}\n\nexport default class Engine implements IEngine {\n\t/**\n\t * Holds all static layers\n\t * Static layers are only re-rendered when told.\n\t */\n\tprivate staticLayers: IRenderingLayer[];\n\n\t/**\n\t * Holds all dynamic layers.\n\t * Dynamic layers are re-rendered every frame.\n\t */\n\tprivate dynamicLayers: IRenderingLayer[];\n\n\t/**\n\t * Variable to know if we should keep rendering.\n\t */\n\tprivate shouldRender: boolean;\n\n\t/**\n\t * The handler ID of the rendering loop\n\t */\n\tprivate renderingId: number | null;\n\n\t/**\n\t * Keeps track of when the last frame was rendered to extract deltas.\n\t */\n\tprivate lastFrameRenderedTime: DOMHighResTimeStamp | null;\n\n\tconstructor() {\n\t\tthis.staticLayers = [];\n\t\tthis.dynamicLayers = [];\n\n\t\t// animation control.\n\t\tthis.shouldRender = true;\n\t\tthis.lastFrameRenderedTime = null;\n\t\tthis.renderingId = null;\n\n\t\t// rebinding.\n\t\tthis.requestFrameA = this.requestFrameA.bind(this);\n\t\tthis.requestFrameB = this.requestFrameB.bind(this);\n\t}\n\n\tgetLayer(layerIndex: LayerIndex, layerType: LayerType) {\n\t\tif (layerType === LayerType.DYNAMIC) {\n\t\t\treturn this.dynamicLayers.find((layer) => layer.layerIndex === layerIndex) || null;\n\t\t} else {\n\t\t\treturn this.staticLayers.find((layer) => layer.layerIndex === layerIndex) || null;\n\t\t}\n\t}\n\n\tregisterLayer(layer: IRenderingLayer) {\n\t\tif (layer.layerType === LayerType.DYNAMIC) {\n\t\t\tthis.dynamicLayers.push(layer);\n\t\t} else {\n\t\t\tthis.staticLayers.push(layer);\n\t\t}\n\t}\n\n\tstart() {\n\t\tthis.shouldRender = true; // say we want to animate.\n\t\tthis.renderingId = window.requestAnimationFrame(this.requestFrameA);\n\t}\n\n\tstop() {\n\t\tthis.shouldRender = false;\n\t\tif (this.renderingId) {\n\t\t\twindow.cancelAnimationFrame(this.renderingId);\n\t\t}\n\t}\n\n\trequestFrameA(timestamp: DOMHighResTimeStamp) {\n\t\tthis.render(timestamp);\n\n\t\tif (this.shouldRender) {\n\t\t\tthis.renderingId = window.requestAnimationFrame(this.requestFrameB);\n\t\t}\n\t}\n\n\trequestFrameB(timestamp: DOMHighResTimeStamp) {\n\t\tthis.render(timestamp);\n\n\t\tif (this.shouldRender) {\n\t\t\tthis.renderingId = window.requestAnimationFrame(this.requestFrameA);\n\t\t}\n\t}\n\n\trender(timestamp: DOMHighResTimeStamp = 0) {\n\t\tif (!this.lastFrameRenderedTime) {\n\t\t\tthis.lastFrameRenderedTime = timestamp;\n\t\t}\n\t\tconst deltaTime = timestamp - this.lastFrameRenderedTime;\n\t\tthis.lastFrameRenderedTime = timestamp;\n\n\t\tfor (let i = 0; i < this.dynamicLayers.length; i++) {\n\t\t\tthis.dynamicLayers[i].update(deltaTime);\n\t\t\tthis.dynamicLayers[i].render();\n\t\t}\n\t}\n}\n","import { LayerType, IEntity, LayerIndex, RenderLayerFunction, UpdateLayerFunction } from '../types';\n\n/**\n * An interface of all necessary functions and properties a rendering layer must have.\n */\nexport interface IRenderingLayer {\n\t/**\n\t * The z-index of the rendering layer.\n\t */\n\treadonly layerIndex: LayerIndex;\n\n\t/**\n\t * Whether the layer is dynamic or static\n\t */\n\treadonly layerType: LayerType;\n\n\t/**\n\t * Width of the document.\n\t */\n\treadonly width: number;\n\n\t/**\n\t * Height of the document\n\t */\n\treadonly height: number;\n\n\t/**\n\t * Render all entities in this layer to the context.\n\t */\n\trender: RenderLayerFunction;\n\n\t/**\n\t * Update all entities in this layer\n\t */\n\tupdate: UpdateLayerFunction;\n\n\t/**\n\t * Get the rendering layer's canvas context.\n\t */\n\tgetContext: () => CanvasRenderingContext2D;\n\n\t/**\n\t * Add a new entity to this rendering layer\n\t * @param entity New entity to be added\n\t */\n\taddEntity(entity: IEntity): void;\n\n\t/**\n\t * Remove an entity from this rendering layer\n\t * @param entity Entity to be removed\n\t */\n\tremoveEntity(entity: IEntity): void;\n}\n\nexport class RenderingLayer implements IRenderingLayer {\n\t/**\n\t * The z-index of the rendering layer\n\t */\n\treadonly layerIndex: LayerIndex;\n\n\t/**\n\t * Whether the layer is dynamic or static.\n\t */\n\treadonly layerType: LayerType;\n\n\t/**\n\t * The canvas' 2D rendering context.\n\t */\n\treadonly context: CanvasRenderingContext2D;\n\n\t/**\n\t * Width of the document.\n\t */\n\treadonly width: number;\n\n\t/**\n\t * Height of the document\n\t */\n\treadonly height: number;\n\n\t/**\n\t * List of entities that are part of this rendering layer.\n\t */\n\tprivate entities: IEntity[];\n\n\t/**\n\t * Construct a new layer that will hold a list of entityes or updaters.\n\t * @param layerIndex Number representing the z-index of the layer on the screen.\n\t * @param layerType Whether the layer elements will be updated on every frame\n\t * @param entity An optional, default first entity.\n\t */\n\tconstructor(layerIndex: LayerIndex, layerType: LayerType, entity?: IEntity) {\n\t\tthis.layerIndex = layerIndex;\n\t\tthis.layerType = layerType;\n\n\t\tthis.entities = [];\n\t\tif (entity) {\n\t\t\tthis.addEntity(entity);\n\t\t}\n\n\t\tthis.width = document.body.clientWidth + 1;\n\t\tthis.height = document.body.clientHeight + 1;\n\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = this.width;\n\t\tcanvas.height = this.height;\n\t\tcanvas.style.top = '0';\n\t\tcanvas.style.left = '0';\n\t\tcanvas.style.position = 'absolute';\n\t\tcanvas.style.zIndex = `${this.layerIndex}`;\n\t\tcanvas.style.display = 'inline';\n\t\tdocument.body.appendChild(canvas);\n\n\t\tconst context = canvas.getContext('2d');\n\t\tif (!context) {\n\t\t\tthrow new Error('Could not initialize canvas 2D context.');\n\t\t}\n\t\tthis.context = context;\n\t\tthis.context.translate(-0.5, -0.5); // disables anti-aliasing\n\t}\n\n\t/**\n\t * Add an entity to this layer\n\t * @param renderElement The entity that will be added to this layer\n\t */\n\taddEntity(entity: IEntity) {\n\t\tif (!this._entityIsRenderable(entity)) {\n\t\t\tthrow new Error('All entities must have a render function.');\n\t\t}\n\t\tif (this.layerType === LayerType.DYNAMIC && !this._entityIsUpdatable(entity)) {\n\t\t\tthrow new Error('All entities of dynamic layers must have an updater function.');\n\t\t}\n\t\tthis.entities.push(entity);\n\t}\n\n\t/**\n\t * Remove an entity from this layer. Effectively, unrendering it.\n\t * @param removeEntity Entity that will be deleted from this layer\n\t */\n\tremoveEntity(removeEntity: IEntity) {\n\t\tconst renderersIdx = this.entities.indexOf(removeEntity);\n\t\tif (renderersIdx !== -1) {\n\t\t\tthis.entities.splice(renderersIdx, 1);\n\t\t}\n\t}\n\n\t/**\n\t * Get the canvas context for this layer\n\t */\n\tgetContext() {\n\t\treturn this.context;\n\t}\n\n\t/**\n\t * Clear the canvas' context.\n\t */\n\tclear() {\n\t\tthis.context.clearRect(-1, -1, this.width, this.height);\n\t}\n\n\t/**\n\t * Update all entities in our rendering layer.\n\t * If the rendering layer is not a dynamic layer, then no update is made.\n\t *\n\t * @param deltaTime Time since the last render in ms.\n\t */\n\tupdate(deltaTime: number) {\n\t\tif (this.layerType !== LayerType.DYNAMIC) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < this.entities.length; i++) {\n\t\t\t// We can force the entity's update function because it is checked in the `addEntity` function.\n\t\t\tthis.entities[i].update!(deltaTime);\n\t\t}\n\t}\n\n\t/**\n\t * Render all entities of this rendering layer after clearing.\n\t */\n\trender() {\n\t\tthis.clear();\n\t\tfor (let i = 0; i < this.entities.length; i++) {\n\t\t\tthis.entities[i].render(this.context);\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the entity has a render function.\n\t * @param entity\n\t */\n\t_entityIsRenderable(entity: IEntity) {\n\t\treturn Boolean(entity.render);\n\t}\n\n\t/**\n\t * Returns true if the entity has an update function.\n\t * @param entity\n\t */\n\t_entityIsUpdatable(entity: IEntity) {\n\t\treturn Boolean(entity.update);\n\t}\n}\n","import Engine from './Engine';\n\nexport { IEngine } from './Engine';\nexport { IRenderingLayer, RenderingLayer } from './RenderingLayer';\nexport * from './types';\n\nexport default Engine;\n","\nexport const enum Colors {\n    BACKGROUND = 'rgb(14, 17, 37)',\n    SCORE_BACKGROUND = '#FF0',\n    SCORE_TEXT = 'rgb(14, 17, 37)',\n    WALLS = 'rgb(17,0,244)',\n    PACMAN = '#FF0',\n};\n\nexport const enum LayerIndex {\n    BACKGROUND,\n    SCORE,\n    ANIMALS,\n    PACMAN,\n};\n\nexport const MIN_MOUTH_SIZE = 0.001; // angle in rads\nexport const MAX_MOUTH_SIZE = 0.2; // angle in rads\nexport const MOUTH_SPEED = MAX_MOUTH_SIZE / 650; // takes x ms to open or close his mouth.\n\nexport const BODY_SPEED = 75 / 650; // 75px movement every 650 ms.\nexport const BODY_RADIUS = 100; // body radius of packman.\n\nexport const pCx = 200;\nexport const pCy = 225;\n\nexport const ANIMAL_SPREAD_DISTANCE = 300;","import { IEntity, IRenderingLayer } from '../../../src';\n\nimport * as DogCatCoveryJpg from '../dog-and-cat-cover.jpg';\n\nimport IManager from './manager';\n\nexport default class Animal implements IEntity {\n\n    layer: IRenderingLayer;\n    animalManager: IManager<Animal>;\n    \n    img: HTMLImageElement;\n    width: number;\n    height: number;\n    x: number;\n    y: number;\n\n    constructor(x: number, y: number, layer: IRenderingLayer, animalManager: IManager<Animal>) {\n        this.layer = layer;\n\n        this.width = 200;\n        this.height = 100;\n        this.x = x;\n        this.y = y - this.height/2;\n\n        const canvasImg = new Image();\n        canvasImg.src = DogCatCoveryJpg.default;\n        canvasImg.onload = this.handleLoad(canvasImg);\n\n        this.animalManager = animalManager;\n    }\n\n    handleLoad = (canvasImg: HTMLImageElement) => () => {\n        this.img = canvasImg;\n        this.animalManager.add(this);\n        this.layer.addEntity(this);\n    }\n\n    getEatten() {\n        this.animalManager.remove(this);\n        this.layer.removeEntity(this);\n    }\n\n    update(deltaTime: number) {\n        // Animals do not move.\n    }\n    \n    render(context: CanvasRenderingContext2D) {\n        if(this.img) {\n            context.drawImage(\n                this.img, \n                this.x, this.y,\n                this.width, this.height\n            );\n        }\n    }\n}","import { IEntity } from '../../../src';\nimport { Colors } from '../constants';\n\nexport default class Background implements IEntity {\n    width: number;\n    height: number;\n\n    constructor(width: number, height: number) {\n        this.width = width;\n        this.height = height;\n    }\n\n    render(context: CanvasRenderingContext2D) {\n        context.fillStyle = Colors.BACKGROUND;\n        context.fillRect(0, 0, this.width, this.height);\n\n        context.fillStyle = Colors.WALLS;\n        context.fillRect(0, 375, this.width, 75);\n        context.fillRect(0, 0, this.width, 75);\n    }\n}","import { IEntity, IRenderingLayer } from \"../../../src\";\n\nimport Score from \"./score\";\nimport Animal from \"./animal\";\n\nimport IManager from './manager';\n\nimport { BODY_RADIUS, pCy, BODY_SPEED, MOUTH_SPEED, MIN_MOUTH_SIZE, MAX_MOUTH_SIZE, Colors } from \"../constants\";\n\n/**\n * https://cwestblog.com/2017/02/02/canvas-animating-pacman-head-in-js/\n * With some modifications.\n */\nexport default class PacMan implements IEntity {\n    layer: IRenderingLayer; // layer used for max width/height.\n    scorer: Score; // layer used for score\n    animalManager: IManager<Animal>;\n\n    radius: number;\n\n    x: number;\n    y: number;\n\n    dx: number;\n    dy: number;\n\n    img: HTMLImageElement;\n    \n    mouthSize: number;\n    mouthDelta: number;\n    mouthStart: number;\n    mouthEnd: number;\n\n    eyeCXdelta: number;\n    eyeCYdelta: number;\n\n    score: number;\n\n    orientation: 'left' | 'right';\n\n    constructor(layer: IRenderingLayer, animalManager: IManager<Animal>, scorer: Score) {\n        this.layer = layer;\n        this.scorer = scorer;\n        this.animalManager = animalManager;\n\n        this.radius = BODY_RADIUS;\n        this.x = layer.width/2;\n        this.y = pCy;\n        this.orientation = 'left';\n\n        this.dx = -BODY_SPEED;\n        this.dy = 0; // not moving in y direction at all.\n\n        this.score = 0;\n\n        this.mouthSize = 0.2;\n        this.mouthDelta = MOUTH_SPEED;\n        this.mouthStart = Math.PI;\n        this.mouthEnd = 2*Math.PI;\n\n        this.eyeCXdelta = 50 * Math.cos(0.3*Math.PI);\n        this.eyeCYdelta = 50 * Math.sin(0.3*Math.PI);\n    }\n\n    isOutOfBounds = (x: number) => (x + this.radius) > this.layer.width || (x - this.radius) < 0;\n\n    changeDirection(directionKey: 'left' | 'right') {\n        if(directionKey === 'left') {\n            this.orientation = 'left';\n            this.dx = -Math.abs(this.dx);\n        } else if(directionKey === 'right') {\n            this.orientation = 'right';\n            this.dx = Math.abs(this.dx);\n        }\n    };\n\n    updateAnimalBounds() {\n        const animals = this.animalManager.get();\n        for(let i = 0; i<animals.length; i++) {\n            const animal = animals[i];\n            let x = this.x;\n            if((animal.x < x) && (animal.x + animal.width) > (this.x + this.radius)) {\n                if(animal.y > (this.y - this.radius) && (animal.y + animal.height) < (this.y + this.radius)) {\n                    animal.getEatten();\n                    this.score += 1;\n                    this.scorer.updateScore(this.score);\n                }\n            }\n        }\n    };\n\n    updateBody(deltaTime: number) {\n        this.mouthSize += this.mouthDelta * deltaTime\n        \n        if(this.mouthSize <= 0 && this.mouthDelta < 0) {\n            // reverse direction\n            this.mouthDelta *= -1;\n        }\n        if(this.mouthSize <= 0) {\n            this.mouthSize = MIN_MOUTH_SIZE;\n        }\n        \n        if(this.orientation === 'left') {\n            this.mouthStart = Math.PI - this.mouthSize*Math.PI;\n            this.mouthEnd = Math.PI + this.mouthSize*Math.PI\n        } else {\n            this.mouthStart = this.mouthSize*Math.PI; // 36 degs in rad\n            this.mouthEnd = (2 - this.mouthSize)*Math.PI; // 324 degs in rad\n        }\n\n        let eyeAngle = (0.25 + this.mouthSize)*Math.PI;\n        this.eyeCXdelta = 50 * Math.cos(eyeAngle);\n        this.eyeCYdelta = 50 * Math.sin(eyeAngle);\n\n        if(this.mouthSize > MAX_MOUTH_SIZE && this.mouthDelta > 0) {\n            // reverse direction\n            this.mouthDelta *= -1;\n        }\n    }\n\n    updatePosition(deltaTime) {\n        const x = this.x + this.dx * deltaTime;\n        if(!this.isOutOfBounds(x)) {\n            this.x = x;\n        }\n        this.updateAnimalBounds();\n    }\n\n    update(deltaTime: number) {\n        this.updateBody(deltaTime);\n        this.updatePosition(deltaTime);\n    }\n\n    render(context: CanvasRenderingContext2D) {\n        const radius = 100;\n\n        context.beginPath();\n        // draw his body\n        context.arc(\n            this.x, this.y, radius, \n            this.mouthStart, this.mouthEnd,\n            this.orientation === 'left'\n        );\n        // line for the mouth, to the center\n        context.lineTo(this.x, this.y);\n        context.closePath();\n        context.fillStyle = Colors.PACMAN;\n        context.fill();\n\n        // outline \n        context.strokeStyle = '#000';\n        context.stroke();\n\n        // A circle for the eye\n        context.beginPath();\n        let eyeOrientation = this.orientation === 'right' ? 1 : -1;\n        context.arc(this.x + this.eyeCXdelta * eyeOrientation, this.y - this.eyeCYdelta, 10, 0, 2 * Math.PI);\n        context.fillStyle = '#000';\n        context.fill();\n\n        // Outline the eye\n        context.strokeStyle = '#FFF';\n        context.stroke();\n\n    }\n}","import { IEntity, IRenderingLayer } from \"../../../src\";\nimport { Colors } from \"../constants\";\n\nexport default class Score implements IEntity {\n    layer: IRenderingLayer;\n\n    width: number;\n    height: number;\n    score: number;\n\n    constructor(layer: IRenderingLayer) {\n        this.layer = layer;\n        this.width = layer.width;\n        this.height = layer.height;\n\n        this.score = 0;\n    }\n\n    updateScore(newScore) {\n        this.score = newScore;\n        this.layer.render();\n    }\n\n    render(context: CanvasRenderingContext2D) {\n        context.fillStyle = Colors.SCORE_BACKGROUND;\n        context.fillRect(this.width - 250, 10, 200, 65);\n\n        context.fillStyle = Colors.SCORE_TEXT;\n        context.font = '30px Arial';\n        context.fillText(`Score: ${this.score}`, this.width - 220, 50);\n    }\n}","\nexport default interface IManager<T> {\n    remove(entity: T): void;\n    add(entity: T): void;\n    get(): T[];\n}\n\nexport class Manager<T> implements IManager<T> {\n\n    entities: T[];\n\n    constructor(){\n        this.entities = [];\n    }\n\n    remove(entity: T) {\n        const idx = this.entities.indexOf(entity);\n        if(idx !== -1) {\n            this.entities.splice(idx, 1);\n        }\n    }\n\n    add(entity: T) {\n        this.entities.push(entity);\n    }\n\n    get() {\n        return this.entities;\n    }\n}\n","import Engine, { RenderingLayer, LayerType } from '../../src';\n\nimport { LayerIndex, pCx, pCy, ANIMAL_SPREAD_DISTANCE } from './constants';\n\nimport Animal from './entities/animal';\nimport Background from './entities/background';\nimport PacMan from './entities/pacman';\nimport Score from './entities/score';\n\nimport { Manager } from './entities/manager';\n\nconst engine = new Engine();\nconst animalManager = new Manager<Animal>();\n\n// Create the background layer\nconst backgroundLayer = new RenderingLayer(LayerIndex.BACKGROUND, LayerType.STATIC);\nconst backgroundEntity = new Background(backgroundLayer.width, backgroundLayer.height);\nbackgroundLayer.addEntity(backgroundEntity);\n\n// Register the layer background.\nengine.registerLayer(backgroundLayer);\n\nbackgroundLayer.render();\n\n\n// Create the animals\nconst animalsLayer = new RenderingLayer(LayerIndex.ANIMALS, LayerType.DYNAMIC);\n// add 6 animals.\nfor (let i = 0; i<6; i++) {\n    animalManager.add(new Animal(pCx + ANIMAL_SPREAD_DISTANCE * i, pCy, animalsLayer, animalManager));\n}\n\n// Register the square layer.\nengine.registerLayer(animalsLayer);\n\n// Create the score layer\nconst scoreLayer = new RenderingLayer(LayerIndex.SCORE, LayerType.STATIC);\nconst scoreEntity = new Score(scoreLayer);\nscoreLayer.addEntity(scoreEntity);\n\n// Register the layer score.\nengine.registerLayer(scoreLayer);\n\nscoreLayer.render();\n\n\n// Create the pacman\nconst pacManLayer = new RenderingLayer(LayerIndex.PACMAN, LayerType.DYNAMIC);\nconst pacMan = new PacMan(pacManLayer, animalManager, scoreEntity);\npacManLayer.addEntity(pacMan);\n\n// Register the pacman layer.\nengine.registerLayer(pacManLayer);\n\n// Start rendering.\nengine.start();\n\ndocument.body.onkeydown = function(keyEvent){\n    if (keyEvent.key === 'd') {\n        pacMan.changeDirection(\"right\");\n    } else if(keyEvent.key === 'a') {\n        pacMan.changeDirection(\"left\");\n    }\n};"]}