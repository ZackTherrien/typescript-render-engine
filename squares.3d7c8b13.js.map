{"version":3,"sources":["../src/types.ts","../src/Engine/index.ts","../src/RenderingLayer/index.ts","../src/index.ts","squares/index.ts"],"names":[],"mappings":"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","file":"squares.3d7c8b13.js","sourceRoot":"../examples","sourcesContent":["/**\n * The function used to render a layer from the engine\n */\nexport type RenderLayerFunction = () => void;\n\n/**\n * Function used to update a layer\n */\nexport type UpdateLayerFunction = (deltaTime: number) => void;\n\n/**\n * The function used to render entities within a layer\n */\nexport type RenderFunction = (context: CanvasRenderingContext2D) => void;\n\n/**\n * Function used to update entities within a layer\n */\nexport type UpdateFunction = (deltaTime: number) => void;\n\n/**\n * Inteface for a generic entity with a render and optional update statement.\n */\nexport interface IEntity {\n\trender: RenderFunction;\n\tupdate?: UpdateFunction;\n}\n\n/**\n * Type of a layer index\n */\nexport type LayerIndex = number;\n\n/**\n * Enum for the layer types.\n * STATIC will not re-render every frame.\n * DYNAMIC will update and re-render every frame.\n */\nexport enum LayerType {\n\tSTATIC,\n\tDYNAMIC,\n}\n","import { IRenderingLayer } from '../RenderingLayer';\n\nimport { LayerType, LayerIndex } from '../types';\n\nexport interface IEngine {\n\t/**\n\t * Start rendering\n\t */\n\tstart(): void;\n\n\t/**\n\t * Stop rendering\n\t */\n\tstop(): void;\n\n\t/**\n\t * Get a layer based on it's index and layer type.\n\t * @param layerIndex The z-index of a layer\n\t * @param layerType The layer type of the layer wanted\n\t */\n\tgetLayer(layerIndex: LayerIndex, layerType: LayerType): IRenderingLayer | null;\n\n\t/**\n\t * Add a layer to the engine.\n\t * @param layer Layer to add to the engine\n\t */\n\tregisterLayer(layer: IRenderingLayer): void;\n}\n\nexport default class Engine implements IEngine {\n\t/**\n\t * Holds all static layers\n\t * Static layers are only re-rendered when told.\n\t */\n\tprivate staticLayers: IRenderingLayer[];\n\n\t/**\n\t * Holds all dynamic layers.\n\t * Dynamic layers are re-rendered every frame.\n\t */\n\tprivate dynamicLayers: IRenderingLayer[];\n\n\t/**\n\t * Variable to know if we should keep rendering.\n\t */\n\tprivate shouldRender: boolean;\n\n\t/**\n\t * The handler ID of the rendering loop\n\t */\n\tprivate renderingId: number | null;\n\n\t/**\n\t * Keeps track of when the last frame was rendered to extract deltas.\n\t */\n\tprivate lastFrameRenderedTime: DOMHighResTimeStamp | null;\n\n\tconstructor() {\n\t\tthis.staticLayers = [];\n\t\tthis.dynamicLayers = [];\n\n\t\t// animation control.\n\t\tthis.shouldRender = true;\n\t\tthis.lastFrameRenderedTime = null;\n\t\tthis.renderingId = null;\n\n\t\t// rebinding.\n\t\tthis.requestFrameA = this.requestFrameA.bind(this);\n\t\tthis.requestFrameB = this.requestFrameB.bind(this);\n\t}\n\n\tgetLayer(layerIndex: LayerIndex, layerType: LayerType) {\n\t\tif (layerType === LayerType.DYNAMIC) {\n\t\t\treturn this.dynamicLayers.find((layer) => layer.layerIndex === layerIndex) || null;\n\t\t} else {\n\t\t\treturn this.staticLayers.find((layer) => layer.layerIndex === layerIndex) || null;\n\t\t}\n\t}\n\n\tregisterLayer(layer: IRenderingLayer) {\n\t\tif (layer.layerType === LayerType.DYNAMIC) {\n\t\t\tthis.dynamicLayers.push(layer);\n\t\t} else {\n\t\t\tthis.staticLayers.push(layer);\n\t\t}\n\t}\n\n\tstart() {\n\t\tthis.shouldRender = true; // say we want to animate.\n\t\tthis.renderingId = window.requestAnimationFrame(this.requestFrameA);\n\t}\n\n\tstop() {\n\t\tthis.shouldRender = false;\n\t\tif (this.renderingId) {\n\t\t\twindow.cancelAnimationFrame(this.renderingId);\n\t\t}\n\t}\n\n\trequestFrameA(timestamp: DOMHighResTimeStamp) {\n\t\tthis.render(timestamp);\n\n\t\tif (this.shouldRender) {\n\t\t\tthis.renderingId = window.requestAnimationFrame(this.requestFrameB);\n\t\t}\n\t}\n\n\trequestFrameB(timestamp: DOMHighResTimeStamp) {\n\t\tthis.render(timestamp);\n\n\t\tif (this.shouldRender) {\n\t\t\tthis.renderingId = window.requestAnimationFrame(this.requestFrameA);\n\t\t}\n\t}\n\n\trender(timestamp: DOMHighResTimeStamp = 0) {\n\t\tif (!this.lastFrameRenderedTime) {\n\t\t\tthis.lastFrameRenderedTime = timestamp;\n\t\t}\n\t\tconst deltaTime = timestamp - this.lastFrameRenderedTime;\n\t\tthis.lastFrameRenderedTime = timestamp;\n\n\t\tfor (let i = 0; i < this.dynamicLayers.length; i++) {\n\t\t\tthis.dynamicLayers[i].update(deltaTime);\n\t\t\tthis.dynamicLayers[i].render();\n\t\t}\n\t}\n}\n","import { LayerType, IEntity, LayerIndex, RenderLayerFunction, UpdateLayerFunction } from '../types';\n\n/**\n * An interface of all necessary functions and properties a rendering layer must have.\n */\nexport interface IRenderingLayer {\n\t/**\n\t * The z-index of the rendering layer.\n\t */\n\treadonly layerIndex: LayerIndex;\n\n\t/**\n\t * Whether the layer is dynamic or static\n\t */\n\treadonly layerType: LayerType;\n\n\t/**\n\t * Width of the document.\n\t */\n\treadonly width: number;\n\n\t/**\n\t * Height of the document\n\t */\n\treadonly height: number;\n\n\t/**\n\t * Render all entities in this layer to the context.\n\t */\n\trender: RenderLayerFunction;\n\n\t/**\n\t * Update all entities in this layer\n\t */\n\tupdate: UpdateLayerFunction;\n\n\t/**\n\t * Get the rendering layer's canvas context.\n\t */\n\tgetContext: () => CanvasRenderingContext2D;\n\n\t/**\n\t * Add a new entity to this rendering layer\n\t * @param entity New entity to be added\n\t */\n\taddEntity(entity: IEntity): void;\n\n\t/**\n\t * Remove an entity from this rendering layer\n\t * @param entity Entity to be removed\n\t */\n\tremoveEntity(entity: IEntity): void;\n}\n\nexport class RenderingLayer implements IRenderingLayer {\n\t/**\n\t * The z-index of the rendering layer\n\t */\n\treadonly layerIndex: LayerIndex;\n\n\t/**\n\t * Whether the layer is dynamic or static.\n\t */\n\treadonly layerType: LayerType;\n\n\t/**\n\t * The canvas' 2D rendering context.\n\t */\n\treadonly context: CanvasRenderingContext2D;\n\n\t/**\n\t * Width of the document.\n\t */\n\treadonly width: number;\n\n\t/**\n\t * Height of the document\n\t */\n\treadonly height: number;\n\n\t/**\n\t * List of entities that are part of this rendering layer.\n\t */\n\tprivate entities: IEntity[];\n\n\t/**\n\t * Construct a new layer that will hold a list of entityes or updaters.\n\t * @param layerIndex Number representing the z-index of the layer on the screen.\n\t * @param layerType Whether the layer elements will be updated on every frame\n\t * @param entity An optional, default first entity.\n\t */\n\tconstructor(layerIndex: LayerIndex, layerType: LayerType, entity?: IEntity) {\n\t\tthis.layerIndex = layerIndex;\n\t\tthis.layerType = layerType;\n\n\t\tthis.entities = [];\n\t\tif (entity) {\n\t\t\tthis.addEntity(entity);\n\t\t}\n\n\t\tthis.width = document.body.clientWidth + 1;\n\t\tthis.height = document.body.clientHeight + 1;\n\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = this.width;\n\t\tcanvas.height = this.height;\n\t\tcanvas.style.top = '0';\n\t\tcanvas.style.left = '0';\n\t\tcanvas.style.position = 'absolute';\n\t\tcanvas.style.zIndex = `${this.layerIndex}`;\n\t\tcanvas.style.display = 'inline';\n\t\tdocument.body.appendChild(canvas);\n\n\t\tconst context = canvas.getContext('2d');\n\t\tif (!context) {\n\t\t\tthrow new Error('Could not initialize canvas 2D context.');\n\t\t}\n\t\tthis.context = context;\n\t\tthis.context.translate(-0.5, -0.5); // disables anti-aliasing\n\t}\n\n\t/**\n\t * Add an entity to this layer\n\t * @param renderElement The entity that will be added to this layer\n\t */\n\taddEntity(entity: IEntity) {\n\t\tif (!this._entityIsRenderable(entity)) {\n\t\t\tthrow new Error('All entities must have a render function.');\n\t\t}\n\t\tif (this.layerType === LayerType.DYNAMIC && !this._entityIsUpdatable(entity)) {\n\t\t\tthrow new Error('All entities of dynamic layers must have an updater function.');\n\t\t}\n\t\tthis.entities.push(entity);\n\t}\n\n\t/**\n\t * Remove an entity from this layer. Effectively, unrendering it.\n\t * @param removeEntity Entity that will be deleted from this layer\n\t */\n\tremoveEntity(removeEntity: IEntity) {\n\t\tconst renderersIdx = this.entities.indexOf(removeEntity);\n\t\tif (renderersIdx !== -1) {\n\t\t\tthis.entities.splice(renderersIdx, 1);\n\t\t}\n\t}\n\n\t/**\n\t * Get the canvas context for this layer\n\t */\n\tgetContext() {\n\t\treturn this.context;\n\t}\n\n\t/**\n\t * Clear the canvas' context.\n\t */\n\tclear() {\n\t\tthis.context.clearRect(-1, -1, this.width, this.height);\n\t}\n\n\t/**\n\t * Update all entities in our rendering layer.\n\t * If the rendering layer is not a dynamic layer, then no update is made.\n\t *\n\t * @param deltaTime Time since the last render in ms.\n\t */\n\tupdate(deltaTime: number) {\n\t\tif (this.layerType !== LayerType.DYNAMIC) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < this.entities.length; i++) {\n\t\t\t// We can force the entity's update function because it is checked in the `addEntity` function.\n\t\t\tthis.entities[i].update!(deltaTime);\n\t\t}\n\t}\n\n\t/**\n\t * Render all entities of this rendering layer after clearing.\n\t */\n\trender() {\n\t\tthis.clear();\n\t\tfor (let i = 0; i < this.entities.length; i++) {\n\t\t\tthis.entities[i].render(this.context);\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the entity has a render function.\n\t * @param entity\n\t */\n\t_entityIsRenderable(entity: IEntity) {\n\t\treturn Boolean(entity.render);\n\t}\n\n\t/**\n\t * Returns true if the entity has an update function.\n\t * @param entity\n\t */\n\t_entityIsUpdatable(entity: IEntity) {\n\t\treturn Boolean(entity.update);\n\t}\n}\n","import Engine from './Engine';\n\nexport { IEngine } from './Engine';\nexport { IRenderingLayer, RenderingLayer } from './RenderingLayer';\nexport * from './types';\n\nexport default Engine;\n","import Engine, { RenderingLayer, LayerType, IEntity, IRenderingLayer } from '../../src';\n\nconst enum Colors {\n    BACKGROUND = '#567D46',\n    SQUARE = '#985629',\n};\n\nconst enum LayerIndex {\n    BACKGROUND,\n    SQUARE,\n};\n\nconst SQUARE_SPEED = 100/1000; // 100 pixels per second\nconst SQUARE_WIDTH = 50;\nconst SQUARE_HEIGHT = 50;\n\nclass Background implements IEntity {\n    width: number;\n    height: number;\n\n    constructor(width: number, height: number) {\n        this.width = width;\n        this.height = height;\n    }\n\n    render(context: CanvasRenderingContext2D) {\n        context.fillStyle = Colors.BACKGROUND;\n        context.fillRect(0, 0, this.width, this.height);\n    }\n}\n\nclass Square implements IEntity {\n    layer: IRenderingLayer; // layer used for max width/height.\n\n    width: number;\n    height: number;\n\n    x: number;\n    y: number;\n\n    dx: number;\n    dy: number;\n\n    constructor(layer: IRenderingLayer) {\n        this.layer = layer;\n        this.width = SQUARE_WIDTH;\n        this.height = SQUARE_HEIGHT;\n\n        this.x = 10;\n        this.y = 10;\n\n        this.dx = 1;\n        this.dy = 1;\n    }\n\n    isXOutOfBounds = () => this.x < 0 || (this.x + SQUARE_WIDTH) > this.layer.width;\n\n    isYOutOfBounds = () => this.y < 0 || (this.y + SQUARE_HEIGHT) > this.layer.height;\n\n    update(deltaTime: number) {\n        const dist = SQUARE_SPEED * deltaTime;\n        this.x += this.dx * dist;\n        this.y += this.dy * dist;\n        if(this.isXOutOfBounds()) {\n            this.dx *= -1; // flip the direction.\n        }\n        if(this.isYOutOfBounds()) {\n            this.dy *= -1; // flip the direction.\n        }\n    }\n\n    render(context: CanvasRenderingContext2D) {\n        context.fillStyle = Colors.SQUARE;\n        context.fillRect(this.x, this.y, this.width, this.height);\n    }\n}\n\nconst engine = new Engine();\n\n// Create the background layer\nconst backgroundLayer = new RenderingLayer(LayerIndex.BACKGROUND, LayerType.STATIC);\nconst backgroundEntity = new Background(backgroundLayer.width, backgroundLayer.height);\nbackgroundLayer.addEntity(backgroundEntity);\n\n// Register the layer background.\nengine.registerLayer(backgroundLayer);\n\n// Since the background is static, it must be rendered manually.\nbackgroundLayer.render();\n\n// Create the square\nconst squareLayer = new RenderingLayer(LayerIndex.SQUARE, LayerType.DYNAMIC);\nconst square = new Square(squareLayer);\nsquareLayer.addEntity(square);\n\n// Register the square layer.\nengine.registerLayer(squareLayer);\n\n// Start rendering.\nengine.start();"]}