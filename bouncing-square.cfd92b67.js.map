{"version":3,"sources":["../src/types.ts","../src/Engine/index.ts","../src/RenderingLayer/index.ts","../src/index.ts","bouncing-square/index.ts"],"names":[],"mappings":"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","file":"bouncing-square.cfd92b67.js","sourceRoot":"../examples","sourcesContent":["/**\n * The function used to render a layer from the engine\n */\nexport type RenderLayerFunction = () => void;\n\n/**\n * Function used to update a layer\n */\nexport type UpdateLayerFunction = (deltaTime: number) => void;\n\n/**\n * The function used to render entities within a layer\n */\nexport type RenderFunction = (context: CanvasRenderingContext2D) => void;\n\n/**\n * Function used to update entities within a layer\n */\nexport type UpdateFunction = (deltaTime: number) => void;\n\n/**\n * Inteface for a generic entity with a render and optional update statement.\n */\nexport interface IEntity {\n\trender: RenderFunction;\n\tupdate?: UpdateFunction;\n}\n\n/**\n * Type of a layer index\n */\nexport type LayerIndex = number;\n\n/**\n * Enum for the layer types.\n * STATIC will not re-render every frame.\n * DYNAMIC will update and re-render every frame.\n */\nexport enum LayerType {\n\tSTATIC,\n\tDYNAMIC,\n}\n\n/**\n * Resize strategy types for the layer resize method.\n * FROM_ORIGIN: will resize the layer but will also make sure the center stays at the same position\n * FROM_CENTER: will resize the layer but will also make sure the top-left stays at the same position\n */\nexport enum ResizeMethod {\n\tFROM_ORIGIN, // from the top left\n\tFROM_CENTER, // from the center\n}\n","import { IRenderingLayer } from '../RenderingLayer';\n\nimport { LayerType, LayerIndex } from '../types';\n\nexport interface IEngine {\n\t/**\n\t * Start rendering\n\t */\n\tstart(): void;\n\n\t/**\n\t * Stop rendering\n\t */\n\tstop(): void;\n\n\t/**\n\t * Get a layer based on it's index and layer type.\n\t * @param layerIndex The z-index of a layer\n\t * @param layerType The layer type of the layer wanted\n\t */\n\tgetLayer(layerIndex: LayerIndex, layerType: LayerType): IRenderingLayer | null;\n\n\t/**\n\t * Add a layer to the engine.\n\t * @param layer Layer to add to the engine\n\t */\n\tregisterLayer(layer: IRenderingLayer): void;\n}\n\nexport default class Engine implements IEngine {\n\t/**\n\t * Holds all static layers\n\t * Static layers are only re-rendered when told.\n\t */\n\tprivate staticLayers: IRenderingLayer[];\n\n\t/**\n\t * Holds all dynamic layers.\n\t * Dynamic layers are re-rendered every frame.\n\t */\n\tprivate dynamicLayers: IRenderingLayer[];\n\n\t/**\n\t * Variable to know if we should keep rendering.\n\t */\n\tprivate shouldRender: boolean;\n\n\t/**\n\t * The handler ID of the rendering loop\n\t */\n\tprivate renderingId: number | null;\n\n\t/**\n\t * Keeps track of when the last frame was rendered to extract deltas.\n\t */\n\tprivate lastFrameRenderedTime: DOMHighResTimeStamp | null;\n\n\tconstructor() {\n\t\tthis.staticLayers = [];\n\t\tthis.dynamicLayers = [];\n\n\t\t// animation control.\n\t\tthis.shouldRender = true;\n\t\tthis.lastFrameRenderedTime = null;\n\t\tthis.renderingId = null;\n\n\t\t// rebinding.\n\t\tthis.requestFrameA = this.requestFrameA.bind(this);\n\t\tthis.requestFrameB = this.requestFrameB.bind(this);\n\t}\n\n\tgetLayer(layerIndex: LayerIndex, layerType: LayerType) {\n\t\tif (layerType === LayerType.DYNAMIC) {\n\t\t\treturn this.dynamicLayers.find((layer) => layer.layerIndex === layerIndex) || null;\n\t\t} else {\n\t\t\treturn this.staticLayers.find((layer) => layer.layerIndex === layerIndex) || null;\n\t\t}\n\t}\n\n\tregisterLayer(layer: IRenderingLayer) {\n\t\tif (layer.layerType === LayerType.DYNAMIC) {\n\t\t\tthis.dynamicLayers.push(layer);\n\t\t} else {\n\t\t\tthis.staticLayers.push(layer);\n\t\t}\n\t}\n\n\tstart() {\n\t\tthis.shouldRender = true; // say we want to animate.\n\t\tthis.renderingId = window.requestAnimationFrame(this.requestFrameA);\n\t}\n\n\tstop() {\n\t\tthis.shouldRender = false;\n\t\tif (this.renderingId) {\n\t\t\twindow.cancelAnimationFrame(this.renderingId);\n\t\t}\n\t}\n\n\trequestFrameA(timestamp: DOMHighResTimeStamp) {\n\t\tthis.render(timestamp);\n\n\t\tif (this.shouldRender) {\n\t\t\tthis.renderingId = window.requestAnimationFrame(this.requestFrameB);\n\t\t}\n\t}\n\n\trequestFrameB(timestamp: DOMHighResTimeStamp) {\n\t\tthis.render(timestamp);\n\n\t\tif (this.shouldRender) {\n\t\t\tthis.renderingId = window.requestAnimationFrame(this.requestFrameA);\n\t\t}\n\t}\n\n\trender(timestamp: DOMHighResTimeStamp = 0) {\n\t\tif (!this.lastFrameRenderedTime) {\n\t\t\tthis.lastFrameRenderedTime = timestamp;\n\t\t}\n\t\tconst deltaTime = timestamp - this.lastFrameRenderedTime;\n\t\tthis.lastFrameRenderedTime = timestamp;\n\n\t\tfor (let i = 0; i < this.dynamicLayers.length; i++) {\n\t\t\tthis.dynamicLayers[i].update(deltaTime);\n\t\t\tthis.dynamicLayers[i].render();\n\t\t}\n\t}\n}\n","import { LayerType, IEntity, LayerIndex, RenderLayerFunction, UpdateLayerFunction, ResizeMethod } from '../types';\n\n/**\n * An interface of all necessary functions and properties a rendering layer must have.\n */\nexport interface IRenderingLayer {\n\t/**\n\t * The z-index of the rendering layer.\n\t */\n\treadonly layerIndex: LayerIndex;\n\n\t/**\n\t * Whether the layer is dynamic or static\n\t */\n\treadonly layerType: LayerType;\n\n\t/**\n\t * Render all entities in this layer to the context.\n\t */\n\trender: RenderLayerFunction;\n\n\t/**\n\t * Update all entities in this layer\n\t */\n\tupdate: UpdateLayerFunction;\n\n\t/**\n\t * Get the rendering layer's canvas context.\n\t */\n\tgetContext: () => CanvasRenderingContext2D;\n\n\t/**\n\t * Get the width of the layer\n\t */\n\tgetWidth: () => number;\n\n\t/**\n\t * Get the height of the layer\n\t */\n\tgetHeight: () => number;\n\n\t/**\n\t * Get the x position of the layer\n\t */\n\tgetX: () => number;\n\n\t/**\n\t * Get the y position of the layer\n\t */\n\tgetY: () => number;\n\n\t/**\n\t * Resize the layer\n\t */\n\tresize: (width: number, height: number, resizeMethod: ResizeMethod) => void;\n\n\t/**\n\t * Add a new entity to this rendering layer\n\t * @param entity New entity to be added\n\t */\n\taddEntity(entity: IEntity): void;\n\n\t/**\n\t * Remove an entity from this rendering layer\n\t * @param entity Entity to be removed\n\t */\n\tremoveEntity(entity: IEntity): void;\n}\n\nexport class RenderingLayer implements IRenderingLayer {\n\t/**\n\t * The z-index of the rendering layer\n\t */\n\treadonly layerIndex: LayerIndex;\n\n\t/**\n\t * Whether the layer is dynamic or static.\n\t */\n\treadonly layerType: LayerType;\n\n\t/**\n\t * The canvas' 2D rendering context.\n\t */\n\treadonly context: CanvasRenderingContext2D;\n\n\t/**\n\t * Width of the layer in the document\n\t */\n\tprivate width: number;\n\n\t/**\n\t * Height of the layer in the document\n\t */\n\tprivate height: number;\n\n\t/**\n\t * X Position of the layer\n\t */\n\tprivate x: number;\n\n\t/**\n\t * X Position of the layer\n\t */\n\tprivate y: number;\n\n\t/**\n\t * List of entities that are part of this rendering layer.\n\t */\n\tprivate entities: IEntity[];\n\n\t/**\n\t * Construct a new layer that will hold a list of entityes or updaters.\n\t * @param layerIndex Number representing the z-index of the layer on the screen.\n\t * @param layerType Whether the layer elements will be updated on every frame\n\t * @param entity An optional, default first entity.\n\t */\n\tconstructor(\n\t\tlayerIndex: LayerIndex,\n\t\tlayerType: LayerType,\n\t\tinitialWidth?: number,\n\t\tinitialHeight?: number,\n\t\tinitialX: number = 0,\n\t\tinitialY: number = 0,\n\t) {\n\t\tthis.layerIndex = layerIndex;\n\t\tthis.layerType = layerType;\n\n\t\tthis.entities = [];\n\n\t\tthis.width = initialWidth === undefined ? document.body.clientWidth + 1 : initialWidth;\n\t\tthis.height = initialHeight === undefined ? document.body.clientHeight + 1 : initialHeight;\n\t\tthis.x = initialX;\n\t\tthis.y = initialY;\n\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.style.position = 'absolute';\n\t\tcanvas.style.zIndex = `${this.layerIndex}`;\n\t\tcanvas.style.display = 'inline';\n\t\tdocument.body.appendChild(canvas);\n\n\t\tconst context = canvas.getContext('2d');\n\t\tif (!context) {\n\t\t\tthrow new Error('Could not initialize canvas 2D context.');\n\t\t}\n\t\tthis.context = context;\n\t\tthis.context.translate(-0.5, -0.5); // disables anti-aliasing\n\t\tthis.resize(this.width, this.height);\n\t\tthis.setPosition(this.x, this.y);\n\t}\n\n\t/**\n\t * Change the size of the layer.\n\t * @param newWidth The new width of the layer\n\t * @param newHeight The new height of the layer\n\t * @param resizeMethod How should we resize the layer: from the center, or from the top-left?\n\t */\n\tresize(newWidth: number, newHeight: number, resizeMethod: ResizeMethod = ResizeMethod.FROM_ORIGIN) {\n\t\tlet xOffset = 0;\n\t\tlet yOffset = 0;\n\t\tif (resizeMethod === ResizeMethod.FROM_CENTER) {\n\t\t\txOffset = (this.width - newWidth) / 2;\n\t\t\tyOffset = (this.height - newHeight) / 2;\n\t\t}\n\n\t\tthis.width = newWidth;\n\t\tthis.height = newHeight;\n\n\t\tthis.context.canvas.width = this.width;\n\t\tthis.context.canvas.height = this.height;\n\n\t\tthis.setPosition(this.x + xOffset, this.y + yOffset);\n\t}\n\n\t/**\n\t * Change the position of this layer\n\t * @param newX the x position where 0 is the left of the document body.\n\t * @param newY the y position where 0 is the top of the document\n\t */\n\tsetPosition(newX: number, newY: number) {\n\t\tthis.x = newX;\n\t\tthis.y = newY;\n\n\t\tif (!this._isLayerWithinBounds()) {\n\t\t\tthrow new Error('Cannot position and resize a layer outside of document body.');\n\t\t}\n\n\t\tthis.context.canvas.style.left = `${this.x}px`;\n\t\tthis.context.canvas.style.top = `${this.y}px`;\n\t}\n\n\t/**\n\t * Add an entity to this layer\n\t * @param renderElement The entity that will be added to this layer\n\t */\n\taddEntity(entity: IEntity) {\n\t\tif (!this._entityIsRenderable(entity)) {\n\t\t\tthrow new Error('All entities must have a render function.');\n\t\t}\n\t\tif (this.layerType === LayerType.DYNAMIC && !this._entityIsUpdatable(entity)) {\n\t\t\tthrow new Error('All entities of dynamic layers must have an updater function.');\n\t\t}\n\t\tthis.entities.push(entity);\n\t}\n\n\t/**\n\t * Remove an entity from this layer. Effectively, unrendering it.\n\t * @param removeEntity Entity that will be deleted from this layer\n\t */\n\tremoveEntity(removeEntity: IEntity) {\n\t\tconst renderersIdx = this.entities.indexOf(removeEntity);\n\t\tif (renderersIdx !== -1) {\n\t\t\tthis.entities.splice(renderersIdx, 1);\n\t\t}\n\t}\n\n\t/**\n\t * Get the width of the layer\n\t */\n\tgetWidth() {\n\t\treturn this.width;\n\t}\n\n\t/**\n\t * Get the height of the layer\n\t */\n\tgetHeight() {\n\t\treturn this.height;\n\t}\n\n\t/**\n\t * Get the x position of the layer\n\t */\n\tgetX() {\n\t\treturn this.x;\n\t}\n\n\t/**\n\t * Get the y position of the layer\n\t */\n\tgetY() {\n\t\treturn this.y;\n\t}\n\n\t/**\n\t * Get the canvas context for this layer\n\t */\n\tgetContext() {\n\t\treturn this.context;\n\t}\n\n\t/**\n\t * Clear the canvas' context.\n\t */\n\tclear() {\n\t\tthis.context.clearRect(-1, -1, this.width, this.height);\n\t}\n\n\t/**\n\t * Update all entities in our rendering layer.\n\t * If the rendering layer is not a dynamic layer, then no update is made.\n\t *\n\t * @param deltaTime Time since the last render in ms.\n\t */\n\tupdate(deltaTime: number) {\n\t\tif (this.layerType !== LayerType.DYNAMIC) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < this.entities.length; i++) {\n\t\t\t// We can force the entity's update function because it is checked in the `addEntity` function.\n\t\t\tthis.entities[i].update!(deltaTime);\n\t\t}\n\t}\n\n\t/**\n\t * Render all entities of this rendering layer after clearing.\n\t */\n\trender() {\n\t\tthis.clear();\n\t\tfor (let i = 0; i < this.entities.length; i++) {\n\t\t\tthis.entities[i].render(this.context);\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the entity has a render function.\n\t * @param entity\n\t */\n\tprivate _entityIsRenderable(entity: IEntity) {\n\t\treturn Boolean(entity.render);\n\t}\n\n\t/**\n\t * Returns true if the entity has an update function.\n\t * @param entity\n\t */\n\tprivate _entityIsUpdatable(entity: IEntity) {\n\t\treturn Boolean(entity.update);\n\t}\n\n\t/**\n\t * Is the layer within the document bounds.\n\t */\n\tprivate _isLayerWithinBounds() {\n\t\treturn (\n\t\t\tthis.width + this.x > document.body.clientWidth ||\n\t\t\tthis.height + this.y > document.body.clientHeight ||\n\t\t\tthis.x < 0 ||\n\t\t\tthis.y < 0\n\t\t);\n\t}\n}\n","import Engine from './Engine';\n\nexport { IEngine } from './Engine';\nexport { IRenderingLayer, RenderingLayer } from './RenderingLayer';\nexport * from './types';\n\nexport default Engine;\n","import Engine, { RenderingLayer, LayerType, IEntity, IRenderingLayer } from '../../src';\n\nconst enum Colors {\n    BACKGROUND = '#567D46',\n    SQUARE = '#985629',\n};\n\nconst enum LayerIndex {\n    BACKGROUND,\n    SQUARE,\n};\n\nconst SQUARE_SPEED = 100/1000; // 100 pixels per second\nconst SQUARE_WIDTH = 50;\nconst SQUARE_HEIGHT = 50;\n\nclass Background implements IEntity {\n    width: number;\n    height: number;\n\n    constructor(width: number, height: number) {\n        this.width = width;\n        this.height = height;\n    }\n\n    render(context: CanvasRenderingContext2D) {\n        context.fillStyle = Colors.BACKGROUND;\n        context.fillRect(0, 0, this.width, this.height);\n    }\n}\n\nclass Square implements IEntity {\n    layer: IRenderingLayer; // layer used for max width/height.\n\n    width: number;\n    height: number;\n\n    x: number;\n    y: number;\n\n    dx: number;\n    dy: number;\n\n    constructor(layer: IRenderingLayer) {\n        this.layer = layer;\n        this.width = SQUARE_WIDTH;\n        this.height = SQUARE_HEIGHT;\n\n        this.x = 10;\n        this.y = 10;\n\n        this.dx = 1;\n        this.dy = 1;\n    }\n\n    isXOutOfBounds = () => this.x < 0 || (this.x + SQUARE_WIDTH) > this.layer.getWidth();\n\n    isYOutOfBounds = () => this.y < 0 || (this.y + SQUARE_HEIGHT) > this.layer.getHeight();\n\n    update(deltaTime: number) {\n        const dist = SQUARE_SPEED * deltaTime;\n        this.x += this.dx * dist;\n        this.y += this.dy * dist;\n        if(this.isXOutOfBounds()) {\n            this.dx *= -1; // flip the direction.\n        }\n        if(this.isYOutOfBounds()) {\n            this.dy *= -1; // flip the direction.\n        }\n    }\n\n    render(context: CanvasRenderingContext2D) {\n        context.fillStyle = Colors.SQUARE;\n        context.fillRect(this.x, this.y, this.width, this.height);\n    }\n}\n\nconst engine = new Engine();\n\n// Create the background layer\nconst backgroundLayer = new RenderingLayer(LayerIndex.BACKGROUND, LayerType.STATIC);\nconst backgroundEntity = new Background(backgroundLayer.getWidth(), backgroundLayer.getHeight());\nbackgroundLayer.addEntity(backgroundEntity);\n\n// Register the layer background.\nengine.registerLayer(backgroundLayer);\n\n// Since the background is static, it must be rendered manually.\nbackgroundLayer.render();\n\n// Create the square\nconst squareLayer = new RenderingLayer(LayerIndex.SQUARE, LayerType.DYNAMIC);\nconst square = new Square(squareLayer);\nsquareLayer.addEntity(square);\n\n// Register the square layer.\nengine.registerLayer(squareLayer);\n\n// Start rendering.\nengine.start();"]}